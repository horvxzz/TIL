# 🌳 트리(Tree) & 🌐 그래프(Graph)

---

## 🌳 1페이지 — 트리(Tree) 기본 개념

### 📘 트리란?

트리(Tree)는 노드(Node)와 간선(Edge)으로 구성된 **계층적(비선형) 자료구조**입니다.

* 루트(Root)에서 시작해 여러 자식 노드를 가질 수 있으며, 노드 간 **순환(Cycle) 구조가 없음**을 보장합니다.
* 현실 세계의 예: 회사 조직도, 폴더 구조, 가족 계보 등.

### 🔹 트리 용어 설명

| 용어         | 의미                    | 예시                |
| ---------- | --------------------- | ----------------- |
| 루트(root)   | 트리의 최상단 노드            | 회사 조직도의 CEO       |
| 부모(parent) | 자신 아래 자식을 가지는 노드      | 팀장                |
| 자식(child)  | 다른 노드를 자신의 아래에 연결한 노드 | 팀원                |
| 리프(leaf)   | 자식이 없는 노드             | 실무자, 말단 직원        |
| 깊이(depth)  | 루트로부터 해당 노드까지의 거리     | CEO로부터 팀원의 위치 3단계 |
| 높이(height) | 트리의 가장 깊은 리프까지 거리     | 전체 조직의 최대 계층 수    |
| 차수(degree) | 노드가 가진 자식 수           | 팀장의 부하 직원 수       |

### 🔹 트리 종류와 상세 설명

1. **이진 트리(Binary Tree)**

   * 각 노드가 최대 두 개의 자식만 가짐.
   * 예: 이진 탐색 구조, 기본 계층 구조.
   * 장점: 구현 단순, 탐색 및 삽입 효율적
   * 단점: 균형이 맞지 않으면 성능 저하 가능

2. **완전 이진 트리(Complete Binary Tree)**

   * 마지막 레벨을 제외하고 모든 레벨이 꽉 차 있으며, 마지막 레벨의 노드는 왼쪽부터 채워짐.
   * 예: 힙 구조
   * 장점: 배열로 구현 가능, 공간 효율적
   * 단점: 동적 삽입/삭제 시 재조정 필요

3. **포화 이진 트리(Full Binary Tree)**

   * 모든 노드가 정확히 두 개의 자식을 가지거나 리프임.
   * 장점: 트리 구조 균형, 완전 탐색 가능
   * 단점: 노드 추가 제한적

4. **이진 탐색 트리(BST)**

   * 왼쪽 서브트리는 루트보다 작은 값, 오른쪽 서브트리는 루트보다 큰 값.
   * 장점: 검색, 삽입, 삭제가 평균적으로 O(log n)
   * 단점: 삽입 순서에 따라 불균형 발생 가능

5. **균형 트리(AVL, Red-Black)**

   * 노드 높이 차이가 일정 수준 이상이면 자동으로 회전 조정.
   * 장점: 항상 탐색 시간 O(log n)
   * 단점: 구현 복잡, 회전 연산 필요

6. **힙(Heap)**

   * 최대값/최소값 우선순위를 빠르게 찾는 트리
   * 최대 힙(Max Heap): 부모 ≥ 자식, 최소 힙(Min Heap): 부모 ≤ 자식
   * 장점: 우선순위 큐 구현, 정렬에 활용 가능
   * 단점: 탐색은 효율적이지 않음

7. **트라이(Trie)**

   * 문자열 검색에 최적화, 각 노드가 문자를 저장
   * 예: 사전, 자동완성 기능
   * 장점: 검색 O(m) (m = 문자열 길이)
   * 단점: 메모리 소모 큼

8. **B/B+ 트리**

   * 데이터베이스 인덱스용, 노드가 다수의 키를 가짐
   * 장점: 대용량 데이터 효율적 탐색
   * 단점: 구현 복잡

### 🔹 트리 장단점 요약

**장점**

* 계층적 데이터 표현 최적
* 탐색, 삽입, 삭제 효율적 (균형 트리 기준)
* 다양한 응용 가능: 탐색, 우선순위 큐, 문자열 처리 등

**단점**

* 구현 복잡
* 균형이 깨지면 탐색 효율 저하
* 특정 트리 종류는 메모리 사용량 많음

---

## 🌳 2페이지 — 트리 구현 예시 (C언어)

### 🔹 기본 이진 트리 구현

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node* left;
    struct Node* right;
} Node;

// 새 노드 생성
Node* createNode(int data) {
    Node* node = (Node*)malloc(sizeof(Node));
    node->data = data;
    node->left = NULL;
    node->right = NULL;
    return node;
}

// 중위 순회 (왼쪽-루트-오른쪽)
void inorder(Node* root) {
    if(root != NULL) {
        inorder(root->left);
        printf("%d ", root->data);
        inorder(root->right);
    }
}

// 노드 개수 계산
int countNodes(Node* root) {
    if(root == NULL) return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
}

// 트리 높이 계산
int treeHeight(Node* root) {
    if(root == NULL) return 0;
    int leftHeight = treeHeight(root->left);
    int rightHeight = treeHeight(root->right);
    return 1 + (leftHeight > rightHeight ? leftHeight : rightHeight);
}

int main() {
    Node* root = createNode(10);
    root->left = createNode(5);
    root->right = createNode(15);
    root->left->left = createNode(3);
    root->left->right = createNode(7);

    printf("중위 순회: ");
    inorder(root);
    printf("\n총 노드 수: %d", countNodes(root));
    printf("\n트리 높이: %d\n", treeHeight(root));

    return 0;
}
```

### 🔹 실행 화면 예시

```
중위 순회: 3 5 7 10 15
총 노드 수: 5
트리 높이: 3
```

### 🔹 코드 리뷰

* `Node` 구조체로 각 노드 정의, `data`, `left`, `right` 포함
* `createNode` 함수로 동적 메모리 할당
* `inorder` 함수로 중위 순회, 값 출력
* `countNodes`와 `treeHeight` 함수로 구조 이해와 분석 가능
* 확장 가능: 삽입, 삭제, 탐색, 균형 유지 기능 추가 가능

---

## 🌐 3페이지 — 그래프(Graph) 기본 개념

### 📘 그래프란?

그래프(Graph)는 **노드(Vertex)와 간선(Edge)으로 구성된 비선형 자료구조**입니다.

* 노드 간 연결 관계를 표현
* **방향 그래프**: 간선에 방향 있음, **무방향 그래프**: 방향 없음
* **사이클 가능**, 순환 여부에 따라 DAG(Directed Acyclic Graph)도 존재
* 현실 예: 지도, 네트워크, 소셜 네트워크, 통신망

### 🔹 그래프 용어

| 용어           | 의미               | 예시         |
| ------------ | ---------------- | ---------- |
| 정점(Vertex)   | 노드               | 도시, 사람     |
| 간선(Edge)     | 노드 연결            | 도로, 친구 관계  |
| 인접(Adjacent) | 연결된 노드           | 연결된 도시     |
| 차수(Degree)   | 연결된 간선 수         | 친구 수       |
| 경로(Path)     | 노드 연결 순서         | A→B→C 이동   |
| 사이클(Cycle)   | 경로가 시작점으로 돌아오는 것 | 도시 A→B→C→A |

### 🔹 그래프 표현 방식

1. **인접 행렬(Adjacency Matrix)**

   * 2차원 배열로 노드 연결 표현
   * 장점: 간선 존재 여부 확인 O(1)
   * 단점: 노드 수 많으면 메모리 비효율적
2. **인접 리스트(Adjacency List)**

   * 각 노드에 연결 리스트로 인접 노드 저장
   * 장점: 메모리 효율적, 간선 순회 O(E)
   * 단점: 특정 간선 존재 확인 O(V)

### 🔹 장단점

**장점**

* 복잡한 관계 모델링 가능
* 네트워크, 지도, 소셜 네트워크 등 활용

**단점**

* 구현 복잡
* 큰 그래프 메모리, 탐색 비용 발생

---

## 🌐 4페이지 — 그래프 구현 예시 (C언어)

### 🔹 인접 리스트 기반 그래프 구현

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

typedef struct Graph {
    int numVertices;
    Node** adjLists;
} Graph;

// 새 노드 생성
Node* createNode(int v) {
    Node* node = (Node*)malloc(sizeof(Node));
    node->vertex = v;
    node->next = NULL;
    return node;
}

// 그래프 생성
Graph* createGraph(int vertices) {
    Graph* graph = (Graph*)malloc(sizeof(Graph));
    graph->numVertices = vertices;
    graph->adjLists = (Node**)malloc(vertices * sizeof(Node*));
    for(int i = 0; i < vertices; i++)
        graph->adjLists[i] = NULL;
    return graph;
}

// 간선 추가
void addEdge(Graph* graph, int src, int dest) {
    Node* node = createNode(dest);
    node->next = graph->adjLists[src];
    graph->adjLists[src] = node;

    node = createNode(src); // 무방향
    node->next = graph->adjLists[dest];
    graph->adjLists[dest] = node;
}

// 그래프 출력
void printGraph(Graph* graph) {
    for(int v = 0; v < graph->numVertices; v++) {
        Node* temp = graph->adjLists[v];
        printf("\n 정점 %d 연결: ", v);
        while(temp) {
            printf("%d ", temp->vertex);
            temp = temp->next;
        }
    }
}

int main() {
    Graph* graph = createGraph(4);
    addEdge(graph, 0, 1);
    addEdge(graph, 0, 2);
    addEdge(graph, 1, 2);
    addEdge(graph, 2, 3);

    printGraph(graph);
    return 0;
}
```

### 🔹 실행 화면 예시

```
정점 0 연결: 2 1
정점 1 연결: 2 0
정점 2 연결: 3 1 0
정점 3 연결: 2
```

### 🔹 코드 리뷰

* `Node` 구조체로 간선 정의, `vertex`와 `next` 포함
* `Graph` 구조체로 전체 그래프 관리, `adjLists` 배열로 각 노드 연결 리스트 저장
* `addEdge` 함수로 무방향 그래프 구현 가능, 방향 그래프는 단방향 추가
* `printGraph`로 인접 리스트 전체 출력
* 확장 가능: DFS/BFS 탐색, 경로 찾기, 최단 경로 알고리즘 구현 가능

---

> 출처: Velog, C언어 공식 문서, 자료구조 교과서
