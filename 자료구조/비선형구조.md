# 🌳 트리(Tree) & 🌐 그래프(Graph)



## 🌳 1. 트리(Tree)

### 📘 선형 구조 vs 비선형 구조

| 구분         | 구조 형태        | 예시                             | 특징                         |
| :--------- | :----------- | :----------------------------- | :------------------------- |
| **선형 구조**  | 데이터가 순서대로 연결 | 리스트(List), 스택(Stack), 큐(Queue) | 앞뒤로 하나씩만 연결됨               |
| **비선형 구조** | 계층적 관계로 연결   | 트리(Tree), 그래프(Graph)           | 한 노드가 여러 자식 또는 부모를 가질 수 있음 |

트리는 비선형 구조의 대표 예시로, **계층적인 관계(부모-자식)** 를 표현하는 자료구조이다.
예: 컴퓨터의 폴더 구조, 조직도, HTML 문서 구조 등

![트리 구조 예시](attachment:749a1ca6-bc58-b4c9d-b71c-e976e4554f9d\:image.png)

---

### 🌲 트리의 정의

> 트리(Tree)는 노드(Node)와 간선(Edge)으로 구성된 **계층적 비선형 자료구조**로, 하나의 루트(Root)에서 여러 개의 자식 노드로 뻗어나간다.
> **사이클(순환)이 존재하지 않는다.**

![트리 예시2](attachment:09d4c927-58d9-46ba-add5-811385cb8388\:image.png)

---

### 🌿 트리의 기본 용어

| 용어                             | 설명                 | 예시                  |
| :----------------------------- | :----------------- | :------------------ |
| **노드(Node)**                   | 트리의 기본 구성요소        | A, B, C…            |
| **루트(Root)**                   | 부모가 없는 최상위 노드      | A                   |
| **부모(Parent)** / **자식(Child)** | 상하 관계              | A는 B의 부모, B는 A의 자식  |
| **리프(Leaf)**                   | 자식이 없는 노드          | K, L, F, G, M, I, J |
| **비단말노드**                      | 자식을 하나 이상 가진 노드    | A, B, C, D, E, H    |
| **서브트리(Subtree)**              | 특정 노드 아래의 모든 하위 트리 | B를 루트로 하는 트리        |
| **깊이(Depth)**                  | 루트에서 특정 노드까지의 거리   | 루트의 깊이는 0           |
| **높이(Height)**                 | 트리에서 가장 깊은 노드의 깊이  | 전체 트리의 높이 = 최대 깊이   |

---

### 🌳 이진 트리 (Binary Tree)

> 모든 노드가 최대 두 개의 자식 노드를 갖는 트리 구조

#### 📋 특징

* 각 노드의 자식 수 ≤ 2 (왼쪽 자식, 오른쪽 자식)
* 모든 서브트리 또한 이진 트리 구조
* 노드의 개수가 `n`개일 때, 간선의 개수는 `n-1`
* 높이가 `h`인 이진 트리의 최대 노드 수: `2^h - 1`

---

### 🌱 이진 트리의 종류

| 종류                       | 정의                          | 예시                | 특징                |
| :----------------------- | :-------------------------- | :---------------- | :---------------- |
| **포화 이진 트리 (Full)**      | 모든 레벨이 꽉 찬 트리               | 모든 노드가 2개의 자식     | 균형적, 구현 복잡도 ↑     |
| **완전 이진 트리 (Complete)**  | 마지막 레벨 제외 모두 채워짐, 마지막은 왼쪽부터 | 힙 구조              | 배열 표현 쉬움          |
| **균형 이진 트리 (Balanced)**  | 왼·오 높이 차 ≤ 1                | AVL, Red-Black 트리 | 탐색 효율적 (O(log n)) |
| **이진 탐색 트리 (BST)**       | 왼쪽 < 루트 < 오른쪽 규칙            | 탐색용 트리            | 삽입·삭제 효율 ↑        |
| **스레드 이진 트리 (Threaded)** | NULL 포인터 활용, 중위 순회 효율화      | 순환 없이 순회 가능       | 구현 복잡             |

---

### 🧮 트리의 표현 방법

#### 📦 배열 표현법

* 트리를 **포화 이진 트리**로 간주하고 배열에 저장
* 인덱스 관계:

  * 부모: i / 2
  * 왼쪽 자식: 2 * i
  * 오른쪽 자식: 2 * i + 1
* 단점: 비어 있는 노드가 많을 경우 메모리 낭비 발생

#### 🔗 링크 표현법 (Linked Representation)

* 각 노드를 구조체로 정의하고, 포인터를 통해 부모→자식 연결

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node* left;
    struct Node* right;
} Node;

Node* createNode(int data) {
    Node* node = (Node*)malloc(sizeof(Node));
    node->data = data;
    node->left = node->right = NULL;
    return node;
}
```

---

### 🔁 트리 순회(Tree Traversal)

| 종류                         | 방문 순서         | 응용         | 사용 자료구조 |
| :------------------------- | :------------ | :--------- | :------ |
| **전위 순회 (Preorder, VLR)**  | 루트 → 왼쪽 → 오른쪽 | 문서 구조 출력   | 재귀 / 스택 |
| **중위 순회 (Inorder, LVR)**   | 왼쪽 → 루트 → 오른쪽 | 수식 트리 계산   | 재귀      |
| **후위 순회 (Postorder, LRV)** | 왼쪽 → 오른쪽 → 루트 | 디렉토리 용량 계산 | 재귀      |
| **레벨 순회 (Level Order)**    | 위에서 아래로       | BFS 기반     | 큐       |

---

### ⚙️ 이진 탐색 트리 (Binary Search Tree)

* 왼쪽 서브트리 < 루트 < 오른쪽 서브트리
* 탐색, 삽입, 삭제 효율적
* 시간복잡도: 균형 O(log n), 최악 O(n)

---

## 🌐 2. 그래프(Graph)

### 📘 그래프 정의

> 그래프(Graph)는 **정점(Vertex)** 과 **간선(Edge)** 으로 이루어진 자료구조로, 객체 간의 연결 상태를 표현
> 우리가 배운 트리도 그래프의 특수한 경우

#### 구성 요소

* **정점(V)**: 데이터를 가지는 객체 (노드라고도 함)
* **간선(E)**: 정점 간 관계를 나타냄 (링크라고도 함)

그래프 G는 (V, E)로 표시

#### 예시

* 전기회로 소자 간 연결 상태
* 지도에서 도시들의 연결 상태

![그래프 예시](attachment\:c2b5fe15-d336-49d8-ac87-81ddfa9b1b29\:image.png)

---

### 🔹 그래프의 종류

| 종류      | 설명              | 예시                       |
| :------ | :-------------- | :----------------------- |
| 무방향 그래프 | 간선에 방향 없음       | A-B == B-A               |
| 방향 그래프  | 간선에 방향 있음       | A→B ≠ B→A                |
| 가중치 그래프 | 간선마다 비용/가중치 존재  | 도시 간 거리                  |
| 부분 그래프  | 원 그래프의 일부 정점·간선 | G1의 일부                   |
| 연결 그래프  | 모든 정점 쌍에 경로 존재  | 네트워크 연결                  |
| 비연결 그래프 | 일부 정점 간 경로 없음   | 고립 노드 존재                 |
| 완전 그래프  | 모든 정점이 서로 연결    | N개의 정점, 간선 수 = N*(N-1)/2 |

---

### 🔹 정점 관련 용어

* **인접 정점**: 하나의 정점에서 직접 연결된 정점
* **차수(Degree)**:

  * 무방향 그래프: 정점에 연결된 간선 수
  * 방향 그래프: 진입차수(외부 → 정점), 진출차수(정점 → 외부)

### 🔹 그래프의 경로와 사이클

* **경로(Path)**: 정점을 따라 이동한 순서
* **단순 경로(Simple Path)**: 정점 반복 없음
* **사이클(Cycle)**: 같은 정점으로 되돌아오는 경로

### 🔹 그래프 표현 방법

1️⃣ **인접 행렬 (Adjacency Matrix)**

* 2차원 배열 사용, 존재 1, 미존재 0
* 구현 쉬움, 희소 그래프는 메모리 낭비

2️⃣ **인접 리스트 (Adjacency List)**

* 각 정점별 연결된 정점 리스트 저장
* 메모리 효율적, 특정 간선 탐색 느림

### 🔹 그래프 탐색

* 하나의 정점에서 시작하여 모든 정점 방문
* 문제 해결의 기본 기법

#### ① 깊이 우선 탐색(DFS)

* 한 방향으로 깊게 탐색, 더 이상 없으면 되돌아감
* 스택 필요 (재귀 호출 시 묵시적 스택)
* 인접행렬 O(V^2), 인접리스트 O(V+E)

#### ② 너비 우선 탐색(BFS)

* 시작 정점에서 가까운 정점부터 방문
* 큐 사용
* 인접행렬 O(V^2), 인접리스트 O(V+E)
